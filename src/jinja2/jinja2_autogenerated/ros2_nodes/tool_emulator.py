#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # Autogenerated ROS2 emulator using jinja2
    # V.1.0.0.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import rclpy
import time
from ros_autogen_testing import tool_emulator_to_driver
from ros_autogen_testing import tool_driver_to_emulator

class tool_emulator():

    def __init__(self, args=None):

        rclpy.init(args=args)

        self.node = rclpy.create_node("tool_emulator")
        self.msg_emulator_to_driver = tool_emulator_to_driver()
        self.msg_driver_to_emulator = tool_driver_to_emulator()
        
        self.idle = 0
        self.running_back = 0
        self.running_forw = 0
        self.torque_reached = 0
        
        self.run_back = 0
        self.run_forw = 0
        self.set_idle = 0
        
        self.torque_tresh = 0

        self.timer_period = 0.1

        self.tool_emulator_sub = self.node.create_subscription(tool_driver_to_emulator, 
                                                                        "/tool_driver_to_emulator", 
                                                                        self.tool_driver_to_emulator_callback)
        self.tool_emulator_pub = self.node.create_publisher(tool_emulator_to_driver, 
                                                                        "/tool_emulator_to_driver")
        self.publisher_tmr = self.node.create_timer(self.timer_period, self.timer_callback)
        self.main_tmr = self.node.create_timer(self.timer_period, self.main_callback)

        rclpy.spin(self.node)
        self.node.destroy_node()
        rclpy.shutdown()
    

    def timer_callback(self):
        
        self.msg_emulator_to_driver.idle = self.idle
        self.msg_emulator_to_driver.running_back = self.running_back
        self.msg_emulator_to_driver.running_forw = self.running_forw
        self.msg_emulator_to_driver.torque_reached = self.torque_reached

        self.pub.publish(self.msg_emulator_to_driver)


    def tool_driver_to_emulator_callback(self, data):
        
        self.run_back = data.run_back
        self.run_forw = data.run_forw
        self.set_idle = data.set_idle
        
        if self.run_back == 1:
        # Do something here
        if self.run_forw == 1:
        # Do something here
        if self.set_idle == 1:
        # Do something here


    def main_callback(self):
        
        # have to send an torque_tresh event back to SP in the state msg
        # or keep state in the node istelf and update just the "torque_reached" line?
        
        # collect the idle state here
        # collect the running_back state here
        # collect the running_forw state here
        # collect the torque_reached state here

        # define stuff here manually

if __name__ == '__main__':
    tool_emulator()