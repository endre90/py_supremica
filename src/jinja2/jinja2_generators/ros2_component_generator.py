#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # ROS2 component generator
    # V.1.0.0.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import os

# Specify package root
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Look for more modules
sys.path.append(root + "/src/generators")
sys.path.append(root + "/src/components")
sys.path.append(root + "/src/algorithms")

from automata_generator import Generator
from automata_synchronizer import Synchronizer
from jinja2 import Template, Environment, PackageLoader, FileSystemLoader


class ComponentGenerator():

    def automaton_based_ros2_node_gen(self, automaton):

        # TODO: some assertions

        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        node_template = env.get_template('jinja2_ros2_node_template.py')

        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes',
                                           '{}_sp_driver.py'.format(automaton.getName()))

        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))

        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))

        # Generate ROS2 node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = automaton.getName(),
                package_name = "ros_autogen_testing",
                message_type_sp_to_driver = '{}_sp_to_driver'.format(automaton.getName()),
                message_type_driver_to_sp = '{}_driver_to_sp'.format(automaton.getName()),
                states = aut_states,
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))


    def automaton_based_ros2_msg_gen(self, automaton):

        # TODO: some assertions

        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        sp_to_driver_msg_template = env.get_template('jinja2_ros2_msg_template_sp_to_driver.msg')
        driver_to_sp_msg_template = env.get_template('jinja2_ros2_msg_template_driver_to_sp.msg')

        sp_to_driver_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages',
                                                       '{}_sp_to_driver.msg'.format(automaton.getName()))
        driver_to_sp_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages',
                                                       '{}_driver_to_sp.msg'.format(automaton.getName()))

        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))

        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))


        # Generate message
        with open(sp_to_driver_msg_filename, 'w') as fh:
            fh.write(sp_to_driver_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))

        # Generate message
        with open(driver_to_sp_msg_filename, 'w') as fh:
            fh.write(driver_to_sp_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
                states = aut_states,
            ))

    def automaton_based_ros2_emulator_node_gen(node, automaton):
#
        # TODO: some assertions
#
        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []
#
        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))
#
        node_template = env.get_template('jinja2_ros2_emulator_node_template.py')
        #
        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes',
                                           '{}_emulator.py'.format(automaton.getName()))
        #
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        #
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))
    #
        # Generate ROS2 node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = automaton.getName(),
                package_name = "ros_autogen_testing",
                message_type_emulator_to_driver = '{}_emulator_to_driver'.format(automaton.getName()),
                message_type_driver_to_emulator = '{}_driver_to_emulator'.format(automaton.getName()),
                states = aut_states,
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))
#
    def automaton_based_ros2_emulator_msg_gen(self, automaton):
#
        # TODO: some assertions
#
        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []
#
        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))
#
        sp_to_driver_msg_template = env.get_template('jinja2_ros2_msg_template_emulator_to_driver.msg')
        driver_to_sp_msg_template = env.get_template('jinja2_ros2_msg_template_driver_to_emulator.msg')
#
        sp_to_driver_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages',
                                                       '{}_emulator_to_driver.msg'.format(automaton.getName()))
        driver_to_sp_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages',
                                                       '{}_driver_to_emulator.msg'.format(automaton.getName()))
        #
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        #
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))
#
#
        # Generate message
        with open(sp_to_driver_msg_filename, 'w') as fh:
            fh.write(sp_to_driver_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))
#
        # Generate message
        with open(driver_to_sp_msg_filename, 'w') as fh:
            fh.write(driver_to_sp_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
                states = aut_states,
            ))

    def sp_model_based_ros2_sp_interfacer_node_gen(self, name, variables, updates):
        # TODO: some assertions

        cmd_vars = []
        msr_vars = []

        for variable in variables:
            if 'set_' in variable:
                cmd_vars.append(variable)
            else:
                msr_vars.append(variable)

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        node_template = env.get_template('jinja2_ros2_sp_interfacer_node_template.py')

        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes',
                                           '{}_sp_interfacer.py'.format(name))

        # Generate ROS2 sp driver node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = name,
                package_name = "unification_ros2_messages",
                message_type_sp_to_interfacer = '{}sptointerfacer'.format('Tool'),
                message_type_interfacer_to_sp = '{}interfacertosp'.format('Tool'),
                message_type_driver_to_interfacer = '{}drivertointerfacer'.format('Tool'),
                message_type_interfacer_to_driver = '{}interfacertodriver'.format('Tool'),
                command_variables = cmd_vars,
                measured_variables = msr_vars,
            ))
        pass

    def list_diff(self, first, second):
        return [item for item in first if item not in second]

    def remove_duplicates(self, items):
        unique = []
        for item in items:
            if item not in unique:
                unique.append(item)
        return unique

    def sp_model_based_ros2_sp_emulator_node_gen(self, name, variables, updates):

        cmd_vars = []
        msr_vars = []
        only_msr_vars = []
        predicates = []
        actions = []
        effects = []
        add_effects = []
        paired = []
        multi = []

        for variable in variables:
            if 'set_' in variable:
                cmd_vars.append(variable)
            else:
                msr_vars.append(variable)

        # isolate the measured only variables like torque_reached for instance
        # this works if there is not a type 1 variable (command only), if there is,
        # than this should be done with some tagging instead...
        for variable in variables:
            if variable in msr_vars:
                for cmd_var in cmd_vars:
                    if variable in cmd_var:
                        paired.append(variable)
                    if variable not in cmd_var:
                        multi.append(variable)

        only_msr_vars = self.remove_duplicates(self.list_diff(multi, paired))
        # print(only_msr_vars)

        for update in updates:
            #print(update)
            predicate = ''
            for elem in update[1][0]:
                if "!" in elem:
                    predicate = predicate + "not self." + elem[1:] + " and "
                else:
                    predicate = predicate + "self." + elem + " and "
            predicates.append(predicate[:-5])
            update[1][1] = ['self.{}'.format(action) for action in update[1][1]]
            actions.append(update[1][1])

            for only_msr_var in only_msr_vars:
                for eff in update[2]:
                    add_effect = []
                    if only_msr_var in eff:
                        print(eff)
                        if "True" in eff:
                            add_effect = [only_msr_var + " = False", only_msr_var + " = True", updates.index(update)] # What to insert and where NOT to insert it
                        elif "False" in eff:
                            add_effect = [only_msr_var + " = True", only_msr_var + " = False", updates.index(update)] # What to insert and where NOT to insert it
                    if add_effect != []:
                        add_effects.append(add_effect)

        print(add_effects)

        for update in updates:
            # for add_effect in add_effects:
            #     if add_effect[1] != updates.index(update):
            #         if add_effect[0] not in update[2]:
            #             if add_effect[1] not in update[2]:
            #                 update[2].append(add_effect[0])


            update[2] = ['self.{}'.format(effect) for effect in update[2]]
            effects.append(update[2])

        print(predicates)
        print(actions)
        print(effects)

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        node_template = env.get_template('jinja2_ros2_sp_emulator_node_template.py')

        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes',
                                           '{}_sp_emulator.py'.format(name))

        #Generate ROS2 sp emulator(effect) node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = name,
                package_name = "unification_ros2_messages",
                message_type_interfacer_to_driver = '{}interfacertodriver'.format('Tool'), # fix this hack
                message_type_driver_to_interfacer = '{}drivertointerfacer'.format('Tool'),
                cmd_vars = cmd_vars,
                msr_vars = msr_vars,
                predicates = predicates,
                actions = actions,
                effects = effects,
            ))
        pass

    def sp_model_based_ros2_node_tests_gen(self, name, variables, updates):

        cmd_vars = []
        msr_vars = []

        for variable in variables:
            if 'set_' in variable:
                cmd_vars.append(variable)
            else:
                msr_vars.append(variable)

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        node_template = env.get_template('jinja2_ros2_sp_node_tests_template.py')

        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes',
                                           '{}_tests.py'.format(name))

        #Generate ROS2 sp emulator(effect) node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = name,
                package_name = "unification_ros2_messages",
                message_type_sp_to_interfacer = '{}sptointerfacer'.format('Tool'), # fix hack
                message_type_interfacer_to_sp = '{}interfacertosp'.format('Tool'),
                cmd_vars = cmd_vars,
                msr_vars = msr_vars,
                updates = updates,
            ))


    def sp_model_based_ros2_msg_gen(self, variables, predicates, actions, effects):
        pass

    def sp_model_based_ros2_simulator_node_gen(self, variables, predicates, actions, effects):
        pass

    def sp_model_based_ros2_hardware_node_gen(self, variables, predicates, actions, effects):
        pass

#
    def efa_based_ros2_node_gen(self, efa):
        return("Not implemented yet")
    #
#
    def efa_based_ros2_msg_gen(self, efa):
        return("Not implemented yet")
