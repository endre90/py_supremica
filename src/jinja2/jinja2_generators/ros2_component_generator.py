#----------------------------------------------------------------------------------------------------------------------#
# authors, description, version
#----------------------------------------------------------------------------------------------------------------------#
    # Endre Er{\H o}s
    # ROS2 component generator
    # V.1.0.0.
#----------------------------------------------------------------------------------------------------------------------#

import sys
import os

# Specify package root
root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

# Look for more modules
sys.path.append(root + "/src/generators")
sys.path.append(root + "/src/components")
sys.path.append(root + "/src/algorithms")

from automata_generator import Generator
from automata_synchronizer import Synchronizer
from jinja2 import Template, Environment, PackageLoader, FileSystemLoader


class ComponentGenerator():

    def automaton_based_ros2_node_gen(self, automaton):
    
        # TODO: some assertions

        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))     

        node_template = env.get_template('jinja2_ros2_node_template.py')
        
        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes', 
                                           '{}_sp_driver.py'.format(automaton.getName()))
        
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))

        # Generate ROS2 node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = automaton.getName(),
                package_name = "ros_autogen_testing",
                message_type_sp_to_driver = '{}_sp_to_driver'.format(automaton.getName()),
                message_type_driver_to_sp = '{}_driver_to_sp'.format(automaton.getName()),
                states = aut_states,
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))
        

    def automaton_based_ros2_msg_gen(self, automaton):

        # TODO: some assertions

        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))

        sp_to_driver_msg_template = env.get_template('jinja2_ros2_msg_template_sp_to_driver.msg')
        driver_to_sp_msg_template = env.get_template('jinja2_ros2_msg_template_driver_to_sp.msg')

        sp_to_driver_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages', 
                                                       '{}_sp_to_driver.msg'.format(automaton.getName()))
        driver_to_sp_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages', 
                                                       '{}_driver_to_sp.msg'.format(automaton.getName()))      
        
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))


        # Generate message
        with open(sp_to_driver_msg_filename, 'w') as fh:
            fh.write(sp_to_driver_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))

        # Generate message
        with open(driver_to_sp_msg_filename, 'w') as fh:
            fh.write(driver_to_sp_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
                states = aut_states,
            ))
        
    def automaton_based_ros2_emulator_node_gen(node, automaton):
# 
        # TODO: some assertions
# 
        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []
# 
        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))     
# 
        node_template = env.get_template('jinja2_ros2_emulator_node_template.py')
        # 
        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes', 
                                           '{}_emulator.py'.format(automaton.getName()))
        # 
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        # 
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))
    # 
        # Generate ROS2 node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = automaton.getName(),
                package_name = "ros_autogen_testing",
                message_type_emulator_to_driver = '{}_emulator_to_driver'.format(automaton.getName()),
                message_type_driver_to_emulator = '{}_driver_to_emulator'.format(automaton.getName()),
                states = aut_states,
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))
# 
    def automaton_based_ros2_emulator_msg_gen(self, automaton):
# 
        # TODO: some assertions
# 
        aut_states = []
        aut_contr_events = []
        aut_uncontr_events = []
# 
        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))
# 
        sp_to_driver_msg_template = env.get_template('jinja2_ros2_msg_template_emulator_to_driver.msg')
        driver_to_sp_msg_template = env.get_template('jinja2_ros2_msg_template_driver_to_emulator.msg')
# 
        sp_to_driver_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages', 
                                                       '{}_emulator_to_driver.msg'.format(automaton.getName()))
        driver_to_sp_msg_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_messages', 
                                                       '{}_driver_to_emulator.msg'.format(automaton.getName()))      
        # 
        for state in automaton.getStates():
            aut_states.append(eval(state.toString()))
        # 
        for event in automaton.getEvents():
            if eval(event.toString()) != ':accepting':
                if event.isControllable():
                    aut_contr_events.append(eval(event.toString()))
                if not event.isControllable():
                    aut_uncontr_events.append(eval(event.toString()))
# 
# 
        # Generate message
        with open(sp_to_driver_msg_filename, 'w') as fh:
            fh.write(sp_to_driver_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
            ))
# 
        # Generate message
        with open(driver_to_sp_msg_filename, 'w') as fh:
            fh.write(driver_to_sp_msg_template.render(
                commands = aut_contr_events,
                replies = aut_uncontr_events,
                states = aut_states,
            ))

    def sp_model_based_ros2_sp_driver_node_gen(self, name, variables, updates):
        
        # TODO: some assertions

        cmd_vars = []
        msr_vars = []

        for variable in variables:
            if 'set_' in variable:
                cmd_vars.append(variable)
            else:
                msr_vars.append(variable)

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))     

        node_template = env.get_template('jinja2_ros2_sp_interfacer_node_template.py')
        
        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes', 
                                           '{}_sp_interfacer.py'.format(name))
        
        # Generate ROS2 sp driver node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = name,
                package_name = "ros_autogen_testing",
                message_type_sp_to_interfacer = '{}_sp_to_interfacer'.format(name),
                message_type_interfacer_to_sp = '{}_interfacer_to_sp'.format(name),
                message_type_driver_to_interfacer = '{}_driver_to_interfacer'.format(name),
                message_type_interfacer_to_driver = '{}_interfacer_to_driver'.format(name),
                command_variables = cmd_vars,
                measured_variables = msr_vars,
            ))
        pass
    
    def sp_model_based_ros2_emulator_node_gen(self, name, variables, updates):

        cmd_vars = []
        msr_vars = []
        predicates = []
        actions = []
        effects = []

        for variable in variables:
            if 'set_' in variable:
                cmd_vars.append(variable)
            else:
                msr_vars.append(variable)
        
        for update in updates:
            print(update)
            predicate = ''
            for elem in update[1][0]:
                predicate = predicate + elem + " and "
            predicates.append(predicate[:-5])
            actions.append(update[1][1])
            effects.append(update[2]) 
        
        #print(predicates)
        #print(actions)
        #print(effects)

        templates_dir = os.path.join(root, 'src', 'jinja2', 'jinja2_templates')
        env = Environment(loader = FileSystemLoader(templates_dir))     

        node_template = env.get_template('jinja2_ros2_sp_emulator_node_template.py')
        
        node_filename = os.path.join(root, 'src', 'jinja2', 'jinja2_autogenerated', 'ros2_nodes', 
                                           '{}_sp_emulator.py'.format(name))
        
        #Generate ROS2 sp effect node
        with open(node_filename, 'w') as fh:
            fh.write(node_template.render(
                resource_name = name,
                package_name = "ros_autogen_testing",
                message_type_interfacer_to_emulator = '{}_interfacer_to_emulator'.format(name),
                message_type_emulator_to_interfacer = '{}_emulator_to_interfacer'.format(name),
                command_variables = cmd_vars,
                measured_variables = msr_vars,
                predicates = predicates,
                actions = actions,
                effects = effects,
            ))
        pass
        
    
    def sp_model_based_ros2_msg_gen(self, variables, predicates, actions, effects):
        pass
    
    def sp_model_based_ros2_simulator_node_gen(self, variables, predicates, actions, effects):
        pass

    def sp_model_based_ros2_hardware_node_gen(self, variables, predicates, actions, effects):
        pass
    
# 
    def efa_based_ros2_node_gen(self, efa):
        return("Not implemented yet")
    # 
# 
    def efa_based_ros2_msg_gen(self, efa):
        return("Not implemented yet")
